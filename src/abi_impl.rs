///! *abi_impl.rs* contains all the implementation (and some tools as
///! abi_bail!) of the massa abi.
///!
///! The ABIs are the imported function / object declared in the webassembly
///! module. You can look at the other side of the mirror in `massa.ts` and the
///! rust side in `execution_impl.rs`.
///!
///! ```rust
///  // execution_impl.rs, create_instance
///! let resolver: ImportObject = imports! {
///! "env" => {
///!     // Needed by wasm generated by AssemblyScript.
///!     "abort" =>  Function::new_native_with_env(&store, env.clone(), assembly_script_abort),
///! },
///! "massa" => {
///!     "assembly_script_print" => Function::new_native_with_env(&store, env.clone(), assembly_script_print),
///!     "assembly_script_call" => Function::new_native_with_env(&store, env.clone(), assembly_script_call_module),
///!     "get_remaining_points" => Function::new_native_with_env(&store, env.clone(), get_remaining_points),
///!     "assembly_script_create_sc" => Function::new_native_with_env(&store, env.clone(), assembly_script_create_sc),
///!     "assembly_script_set_data" => Function::new_native_with_env(&store, env.clone(), assembly_script_set_data),
///!     "assembly_script_set_data_for" => Function::new_native_with_env(&store, env.clone(), assembly_script_set_data_for),
///!     "assembly_script_get_data" => Function::new_native_with_env(&store, env.clone(), assembly_script_get_data),
///!     "assembly_script_get_data_for" => Function::new_native_with_env(&store, env, assembly_script_get_data_for),
///! },
///! };
///! ```
use crate::env::{
    get_remaining_points_for_env, sub_remaining_point, sub_remaining_points_with_ratio, Env,
};
use crate::types::{Address, Response};
use crate::{settings, Bytecode};
use anyhow::Result;
use as_ffi_bindings::{Read as ASRead, StringPtr, Write as ASWrite};
use wasmer::Memory;

#[derive(Debug, Clone)]
pub(crate) struct ExitCode(pub(crate) String);
impl std::fmt::Display for ExitCode {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}
impl std::error::Error for ExitCode {}
macro_rules! abi_bail {
    ($err:expr) => {
        wasmer::RuntimeError::raise(Box::new(crate::abi_impl::ExitCode($err.to_string())))
    };
}
macro_rules! get_memory {
    ($env:ident) => {
        match $env.wasm_env.memory.get_ref() {
            Some(mem) => mem,
            _ => abi_bail!("uninitialized memory"),
        }
    };
}
pub(crate) use abi_bail;
pub(crate) use get_memory;

/// `Call` ABI called by the webassembly VM
///
/// Call an exported function in a WASM module at a given address
///
/// It take in argument the environment defined in env.rs
/// this environment is automatically filled by the wasmer library
/// And two pointers of string. (look at the readme in the wasm folder)
fn call_module(env: &Env, address: &Address, function: &str, param: &str) -> Result<Response> {
    let module = &env.interface.get_module(address)?;
    crate::execution_impl::exec(
        get_remaining_points_for_env(env),
        None,
        module,
        function,
        param,
        &*env.interface,
    )
}

fn create_sc(env: &Env, bytecode: &Bytecode) -> Result<Address> {
    env.interface.create_module(bytecode)
}

/// Raw call that have the right type signature to be able to be call a module
/// directly form AssemblyScript:
///
#[doc = include_str!("../wasm/README.md")]
pub(crate) fn assembly_script_call_module(
    env: &Env,
    address: i32,
    function: i32,
    param: i32,
) -> i32 {
    sub_remaining_point(env, settings::metering_call());
    let memory = get_memory!(env);
    let addr_ptr = StringPtr::new(address as u32);
    let func_ptr = StringPtr::new(function as u32);
    let param_ptr = StringPtr::new(param as u32);

    let address = addr_ptr.read(memory);
    let function = func_ptr.read(memory);
    let param = param_ptr.read(memory);
    if address.is_err() || function.is_err() || param.is_err() {
        abi_bail!("Cannot read address, function or param in memory in call module request ABI")
    }
    let address = &address.unwrap();
    let function = &function.unwrap();
    let param = &param.unwrap();
    let value = call_module(env, address, function, param);
    if value.is_err() {
        abi_bail!(value.err().unwrap())
    }
    if let Ok(ret) = StringPtr::alloc(&value.unwrap().ret, &env.wasm_env) {
        ret.offset() as i32
    } else {
        abi_bail!(format!(
            "Cannot allocate response in call {}::{}",
            address, function
        ))
    }
}

pub(crate) fn get_remaining_points(env: &Env) -> i32 {
    sub_remaining_point(env, settings::metering_remaining_points());
    get_remaining_points_for_env(env) as i32
}

/// Create an instance of VM from a module with a
/// given intefrace, an operation number limit and a webassembly module
///
/// An utility print function to write on stdout directly from AssemblyScript:
pub(crate) fn assembly_script_print(env: &Env, arg: i32) {
    sub_remaining_point(env, settings::metering_print());
    let str_ptr = StringPtr::new(arg as u32);
    let memory = get_memory!(env);
    if let Ok(message) = &str_ptr.read(memory) {
        if env.interface.print(message).is_err() {
            abi_bail!("Failed to print message");
        }
    } else {
        abi_bail!("Cannot read message pointer in memory");
    }
}

/// Read a bytecode string, representing the webassembly module binary encoded
/// with in base64.
pub(crate) fn assembly_script_create_sc(env: &Env, bytecode: i32) -> i32 {
    let memory = get_memory!(env);
    // Base64 to Binary
    let bytecode = match base64::decode(read_string_and_sub_points(
        env,
        memory,
        bytecode,
        settings::metering_create_sc_ratio(),
    )) {
        Ok(bytecode) => bytecode,
        Err(err) => abi_bail!(err),
    };
    let address = match create_sc(env, &bytecode) {
        Ok(address) => address,
        Err(err) => abi_bail!(err),
    };
    match StringPtr::alloc(&address, &env.wasm_env) {
        Ok(ptr) => ptr.offset() as i32,
        Err(err) => abi_bail!(err),
    }
}

pub(crate) fn assembly_script_set_data(env: &Env, key: i32, value: i32) {
    let memory = env.wasm_env.memory.get_ref().expect("uninitialized memory");
    let key = StringPtr::new(key as u32).read(memory);
    let value = read_string_and_sub_points(env, memory, value, settings::metering_set_data_ratio());
    if key.is_err() {
        abi_bail!("Invalid pointer of key");
    }
    if let Err(err) = env
        .interface
        .set_data(&key.unwrap(), &value.as_bytes().to_vec())
    {
        abi_bail!(err)
    }
}

pub(crate) fn assembly_script_get_data(env: &Env, key: i32) -> i32 {
    let memory = env.wasm_env.memory.get_ref().expect("uninitialized memory");
    let key = StringPtr::new(key as u32).read(memory);
    if key.is_err() {
        abi_bail!("Invalid pointer of key");
    }
    match env.interface.get_data(&key.unwrap()) {
        Ok(data) => {
            sub_remaining_points_with_ratio(env, data.len(), settings::metering_get_data_ratio());
            pointer_from_utf8(env, &data).offset() as i32
        }
        Err(err) => abi_bail!(err),
    }
}

pub(crate) fn assembly_script_set_data_for(env: &Env, address: i32, key: i32, value: i32) {
    let memory = env.wasm_env.memory.get_ref().expect("uninitialized memory");
    let value = read_string_and_sub_points(env, memory, value, settings::metering_set_data_ratio());
    let address = StringPtr::new(address as u32).read(memory);
    let key = StringPtr::new(key as u32).read(memory);
    if key.is_err() || address.is_err() {
        abi_bail!("Invalid pointer of key, value or address");
    }
    if let Err(err) =
        env.interface
            .set_data_for(&address.unwrap(), &key.unwrap(), &value.as_bytes().to_vec())
    {
        abi_bail!(err)
    }
}

pub(crate) fn assembly_script_get_data_for(env: &Env, address: i32, key: i32) -> i32 {
    let memory = env.wasm_env.memory.get_ref().expect("uninitialized memory");
    let address = StringPtr::new(address as u32).read(memory);
    let key = StringPtr::new(key as u32).read(memory);
    if key.is_err() || address.is_err() {
        abi_bail!("Invalid pointer of key or address");
    }
    match env.interface.get_data_for(&address.unwrap(), &key.unwrap()) {
        Ok(data) => {
            sub_remaining_points_with_ratio(env, data.len(), settings::metering_get_data_ratio());
            pointer_from_utf8(env, &data).offset() as i32
        }
        Err(err) => abi_bail!(err),
    }
}

/// Tooling, return a StringPtr allocated from a bytecode with utf8 parsing
///
fn pointer_from_utf8(env: &Env, bytecode: &Bytecode) -> StringPtr {
    match std::str::from_utf8(bytecode) {
        Ok(data) => match StringPtr::alloc(&data.to_string(), &env.wasm_env) {
            Ok(ptr) => *ptr,
            Err(err) => abi_bail!(err),
        },
        Err(err) => abi_bail!(err),
    }
}

/// Tooling that take read a String in memory and substract remaining points
/// with a ratio String.len / ratio.
///
/// Sub funtion of `assembly_script_set_data_for`, `assembly_script_set_data`
/// and `assembly_script_create_sc`
///
/// Return the string value in the StringPtr
fn read_string_and_sub_points(env: &Env, memory: &Memory, offset: i32, ratio: usize) -> String {
    match StringPtr::new(offset as u32).read(memory) {
        Ok(value) => {
            sub_remaining_points_with_ratio(env, value.len(), ratio);
            value
        }
        Err(err) => abi_bail!(err),
    }
}
